# 02 Enable Kubernetes on "Docker for Mac"

## Prerequisites

Please make sure you've installed the "Docker for Mac". Just follow the installation instruction with the official doc [Install Docker Desktop on Mac](https://docs.docker.com/docker-for-mac/install/).

![](../.gitbook/assets/image%20%2817%29.png)

## Goals

Enable the Kubernetes on "Docker for Mac" is quit easy, just follow [this instruction](https://docs.docker.com/docker-for-mac/#kubernetes) to enable it. But what I want is to make sure the Kubernetes can reserve as many resources as it can, cause it will need to support to run the k8s-bundle includes Prometheus/ELK/CI/CD, etc. And we also want to solve other problems, here's the goats.

* Enlarge the limitation of the docker daemon's CPU, memory & disk
* Setup network proxy to make sure we can by pass the [Great Firewall](https://en.wikipedia.org/wiki/Great_Firewall)
* Modify the `~/.kube/config` to make it accessible from network
* \[Extra\] Make [kubeconfig](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/) `~/.kube/config` accessible from the Internet

Let's go dive into each goals.

## Enlarge the limitation of CPU, memory & disk

As I said, we want to make sure the Kubernetes running on "Docker for Mac" can support as many services \(Prometheus/ELK/CI/CD, etc\) as it can, so we need to enlarge the limitation of the CPU, memory & disk of the Docker daemon itself before we enable the Kubernetes.

Choose the Docker menu ![whale menu](https://docs.docker.com/docker-for-mac/images/whale-x.png) &gt; **Preferences** from the menu bar and go to the &gt; **Resources** **&gt; Advanced** tab, configure CPU, memory, disk for your own, this is my configuration.

![](../.gitbook/assets/image%20%2821%29.png)

{% hint style="warning" %}
As you can see, I just allocated all the system's CPUs & Memory together with 4GB Swap to the Docker daemon, and I will enable the Kubernetes later on. The CPU load will be very high, and the temperature of my Mac mini can up to 60 **Â°C**, but I don't care about that, I just let it be my real Kubernetes servers, I don't run other tasks on the Mac mini, it's runing very stable till now.  **Please take your own risk!**
{% endhint %}

![](../.gitbook/assets/image%20%2811%29.png)

![](../.gitbook/assets/image%20%2820%29.png)

## Setup network proxy to make sure we can by pass the Great Firewall

If you're in mainland China, you need to setup `Proxies` for your Docker, otherwise the Kubernetes will most likely stucked in _Kubernetes is starting_.

Choose the Docker menu ![whale menu](https://docs.docker.com/docker-for-mac/images/whale-x.png) &gt; **Preferences** from the menu bar and go to the &gt; **Resources** **&gt; PROXIES** tab, enable the "Manual proxy configuration" and configure "HTTP" & "HTTPS" to your own proxy service. This is my configuration.

![](../.gitbook/assets/image%20%2813%29.png)

## Enable Kubernetes

Now it's time to enable the Kubernetes.

Choose the Docker menu ![whale menu](https://docs.docker.com/docker-for-mac/images/whale-x.png) &gt; **Preferences** from the menu bar and go to the &gt; **Kubernetes** tab, check "Enable Kubernetes" and click on "Apply & Restart".

![](../.gitbook/assets/image%20%2810%29.png)

Wait for minutes until the Kubernetes is running in the Docker menu.

![](../.gitbook/assets/image%20%2815%29.png)

Now let's run the `kubectl` command to check if we can interact with the Kubernetes.

```text
$ kubectl get pod
No resources found in default namespace.
```

## Modify the `~/.kube/config` to make it accessible from network

The current kubeconfig file `~/.kube/config` was generated by automatically by enable the Kubernetes with above step, it can only be used on the local Mac for now, we should modify it to make it accessible from network.

Looking into the default kubeconfig file `~/.kube/config` we can see the server is set to `https://kubernetes.docker.internal:6443` which we can found it in `/etc/hosts` that it points to `127.0.0.1`.

```text
$ cat ~/.kube/config
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: <....>
    server: https://kubernetes.docker.internal:6443
  name: docker-desktop
contexts:
.....

$ cat ~/.kube/config
cat /etc/hosts
...
# Added by Docker Desktop
# To allow the same kube context to work on the host and the container:
127.0.0.1 kubernetes.docker.internal
# End of section
```

Now let's change the kubeconfig `~/.kube/config` :

* Change the server field from `https://kubernetes.docker.internal:6443` to `https://<your-ip-address>:6444`

{% hint style="info" %}
Port `6444` will be the port which `socat` is listening on, we will talk about it later.
{% endhint %}

* Delete the whole line `certificate-authority-data`
* Add below line after the server field to use `insecure-skip-tls-verify` [option](https://kubernetes.io/docs/reference/kubectl/kubectl/#options)

```text
insecure-skip-tls-verify: true
```

* The new kubeconfig file should look like this

```text
apiVersion: v1
clusters:
- cluster:
    insecure-skip-tls-verify: true
    server: https://<your-ip-address>:6444
  name: docker-desktop
...
```

* **Save your changes and copy to any computers where their `kubectl` can it to access this Kubernetes with the changed kubeconfig**

The kube API requests should be sent to the new endpoint, but the Kubenetes API server never replys, it's only running & listening on `127.0.0.1` not on &lt;your-ip-address&gt;, we should use some forwarding method to forward the requests to &lt;your-ip-address&gt;:6444 to `127.0.0.1:6443`. Using `socat` is one method.

```text
$ brew install socat
$ socat TCP-LISTEN:6444,fork TCP:127.0.0.1:6443
```

Test the new kubeconfig `~/.kube/config`:

```text
$ kubectl version
Client Version: version.Info{Major:"1", Minor:"16", GitVersion:"v1.16.2", GitCommit:"c97fe5036ef3df2967d086711e6c0c405941e14b", GitTreeState:"clean", BuildDate:"2019-10-15T23:42:50Z", GoVersion:"go1.12.10", Compiler:"gc", Platform:"darwin/amd64"}
Server Version: version.Info{Major:"1", Minor:"16+", GitVersion:"v1.16.6-beta.0", GitCommit:"e7f962ba86f4ce7033828210ca3556393c377bcc", GitTreeState:"clean", BuildDate:"2020-01-15T08:18:29Z", GoVersion:"go1.13.5", Compiler:"gc", Platform:"linux/amd64"}
```

## \[Extra\] Make kubeconfig ~/.kube/config accessible from the Internet

{% hint style="info" %}
This is not a nessiccry step, the user cases for me to make it accessible from the Internet are:

* Manage Kubenetes from the Internet from anywhere
* CicleCI [steps](https://github.com/georgedriver/k8s-bundle/blob/master/.circleci/config.yml#L37) need to access it from the Internet
* The ingress domain for my services can be accessed from the Internetes \(ISP doesn't open 80/8080/443 for home network
{% endhint %}

Requirements for this goal:

* Can get a fixed IP public address \(this will be changed most likely periodcally\) from your ISP
* Use [DDNS](https://en.wikipedia.org/wiki/Dynamic_DNS) to map your DDNS domain to your changed public addresses from the ISP
* Expose your `6444` port of your kube API to the Internet \(**dangerous**: make sure keep your kubeconfig  safely\)
* Expose your `8443` port to expose your `https` ingress domains \(**dangerous**: make sure you only expose the https services as necessary\)

My setup for your reference:

Please refer to the section "\[Extra\] Home network topology" from "00 Goals" to see my home network topology.

*  Xiaomi 3G Router

![](../.gitbook/assets/image%20%287%29.png)

![](../.gitbook/assets/image%20%2816%29.png)

![](../.gitbook/assets/image%20%2814%29.png)

Now all the traffic to my DDNS domain should be routed to my **PA220 \(192.168.123.93\)**.

* PA220 setup

NAT

![](../.gitbook/assets/image%20%286%29.png)

Security

![](../.gitbook/assets/image%20%289%29.png)

Now all the traffic \(6444 and 8443\) should be ok to be routed to our Kubernetes host `192.168.88.6`.



